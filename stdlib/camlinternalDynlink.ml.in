(* @configure_input@ *)
#3 "camlinternalDynlink.ml.in"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                   Sebastien Hinderer, Tarides, Paris                   *)
(*                                                                        *)
(*   Copyright 2022 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module LongString = struct
  type t = bytes array

  let create str_size =
    let tbl_size = str_size / Sys.max_string_length + 1 in
    let tbl = Array.make tbl_size Bytes.empty in
    for i = 0 to tbl_size - 2 do
      tbl.(i) <- Bytes.create Sys.max_string_length;
    done;
    tbl.(tbl_size - 1) <- Bytes.create (str_size mod Sys.max_string_length);
    tbl

  let length tbl =
    let tbl_size = Array.length tbl in
    Sys.max_string_length * (tbl_size - 1) + Bytes.length tbl.(tbl_size - 1)

  let get tbl ind =
    Bytes.get tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)

  let set tbl ind c =
    Bytes.set tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)
              c
  let blit src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      set dst (dstoff + i) (get src (srcoff + i))
    done

  let blit_string src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      set dst (dstoff + i) (String.get src (srcoff + i))
    done

  let output oc tbl pos len =
    for i = pos to pos + len - 1 do
      output_char oc (get tbl i)
    done

  let input_bytes_into tbl ic len =
    let count = ref len in
    Array.iter (fun str ->
      let chunk = Int.min !count (Bytes.length str) in
      really_input ic str 0 chunk;
      count := !count - chunk) tbl

  let input_bytes ic len =
    let tbl = create len in
    input_bytes_into tbl ic len;
    tbl
end

let load_compunit_code ic code_size =
  let opRETURN = 40 in (* keep in sync with bytecomp/opcodes.ml *)
  let terminator = "\000\000\000\001\000\000\000" in
  let size = code_size + 8 in
  let code = LongString.create size in
  LongString.input_bytes_into code ic code_size;
  LongString.set code code_size (Char.chr opRETURN);
  LongString.blit_string terminator 0 code (code_size + 1) 7;
  code

(* Length of magic numbers, keep in sync with utils/misc.ml *)
let magic_length = 12

let cmo_magic_number = {@QS@|@CMO_MAGIC_NUMBER@|@QS@}
and cma_magic_number = {@QS@|@CMA_MAGIC_NUMBER@|@QS@}
and cmxs_magic_number = {@QS@|@CMXS_MAGIC_NUMBER@|@QS@}

(* The CMO format, keep in sync with file_formats/cmo_format.mli *)

type modname = string
type crcs = (modname * Digest.t option) list

(* Relocation information *)

type reloc_info =
    Reloc_literal of Obj.t                  (* structured constant *)
  | Reloc_getpredef of string               (* reference to a predef *)
  | Reloc_getglobal of string               (* reference to a global *)
  | Reloc_setglobal of string               (* definition of a global *)
  | Reloc_primitive of string               (* C primitive number *)

(* Descriptor for compilation units *)

type compilation_unit =
  { cu_name: modname;                   (* Name of compilation unit *)
    mutable cu_pos: int;                (* Absolute position in file *)
    cu_codesize: int;                   (* Size of code block *)
    cu_reloc: (reloc_info * int) list;  (* Relocation information *)
    cu_imports: crcs;                   (* Names and CRC of intfs imported *)
    cu_required_globals: string list;   (* Compilation units whose
                                           initialization side effects
                                           must occur before this one. *)
    cu_primitives: string list;         (* Primitives declared inside *)
    mutable cu_force_link: bool;        (* Must be linked even if unref'ed *)
    mutable cu_debug: int;              (* Position of debugging info, or 0 *)
    cu_debugsize: int }                 (* Length of debugging info *)

(* Format of a .cmo file:
     magic number (Config.cmo_magic_number)
     absolute offset of compilation unit descriptor
     block of relocatable bytecode
     debugging information if any
     compilation unit descriptor *)

(* Descriptor for libraries *)

type library =
  { lib_units: compilation_unit list;   (* List of compilation units *)
    lib_custom: bool;                   (* Requires custom mode linking? *)
    (* In the following fields the lists are reversed with respect to
       how they end up being used on the command line. *)
    lib_ccobjs: string list;            (* C object files needed for -custom *)
    lib_ccopts: string list;            (* Extra opts to C compiler *)
    lib_dllibs: string list }           (* DLLs needed *)

(* Format of a .cma file:
     magic number (Config.cma_magic_number)
     absolute offset of library descriptor
     object code for first library member
     ...
     object code for last library member
     library descriptor *)

(* The CMXS format, keep in sync with file_formats/cmxs_format.mli *)

(* Each .cmxs dynamically-loaded plugin contains a symbol
   "caml_plugin_header" containing the following info
   (as an externed record) *)

type dynunit = {
  dynu_name: modname;
  dynu_crc: Digest.t;
  dynu_imports_cmi: crcs;
  dynu_imports_cmx: crcs;
  dynu_defines: string list;
}

type dynheader = {
  dynu_magic: string;
  dynu_units: dynunit list;
}

exception Fatal_error

let fatal_errorf fmt =
  Format.kfprintf
    (fun _ -> raise Fatal_error)
    Format.err_formatter
    ("@?>> Fatal error: " ^^ fmt ^^ "@.")

let fatal_error msg = fatal_errorf "%s" msg

let ext_dll = "." ^ {@QS@|@SO@|@QS@}

(* Extract the name of a DLL from its external name (xxx.so or -lxxx) *)

let extract_dll_name file =
  if Filename.check_suffix file ext_dll then
    Filename.chop_suffix file ext_dll
  else if String.length file >= 2 && String.sub file 0 2 = "-l" then
    "dll" ^ String.sub file 2 (String.length file - 2)
  else
    file (* will cause error later *)

(* Handling of dynamically-linked libraries *)

type dll_handle
type dll_address

external dll_open: string -> dll_handle = "caml_dynlink_open_lib"
external dll_close: dll_handle -> unit = "caml_dynlink_close_lib"
external dll_sym: dll_handle -> string -> dll_address
                = "caml_dynlink_lookup_symbol"
         (* returned dll_address may be Val_unit *)

external add_primitive: dll_address -> int = "caml_dynlink_add_primitive"
external get_current_dlls: unit -> dll_handle array
                                           = "caml_dynlink_get_current_libs"

(* Current search path for DLLs *)
let search_path = ref ([] : string list)

(* DLLs currently opened for execution *)
let dlls_opened_for_execution = ref ([] : (string * dll_handle) list)

(* Add the given directories to the search path for DLLs. *)
let add_path dirs =
  search_path := dirs @ !search_path

(* Use the given directories as the search path for DLLs. *)
let set_path dirs =
  search_path := dirs

let remove_path dirs =
  search_path := List.filter (fun d -> not (List.mem d dirs)) !search_path

(* Copied from utils/misc.ml *)
let find_in_path path name =
  if not (Filename.is_implicit name) then
    if Sys.file_exists name then name else raise Not_found
  else begin
    let rec try_dir = function
      [] -> raise Not_found
    | dir::rem ->
        let fullname = Filename.concat dir name in
        if Sys.file_exists fullname then fullname else try_dir rem
    in try_dir path
  end

let fullname_of_name name =
  let name = name ^ ext_dll in
  try
    let fullname = find_in_path !search_path name in
    if Filename.is_implicit fullname then
      Filename.concat Filename.current_dir_name fullname
    else fullname
  with Not_found -> name

let open_dll_for_execution name =
  let fullname = fullname_of_name name in
  match List.assoc_opt fullname !dlls_opened_for_execution with
  | Some _ -> () (* DLL has already been opened *)
  | None ->
      begin match dll_open fullname with
      | dll ->
          dlls_opened_for_execution :=
            (fullname, dll) :: !dlls_opened_for_execution
      | exception Failure msg ->
          failwith (fullname ^ ": " ^ msg)
      end

(* Close all DLLs *)

let close_all_dlls () =
  List.iter (fun (_, dll) -> dll_close dll) !dlls_opened_for_execution;
  dlls_opened_for_execution := []

(* Find a primitive in the currently opened DLLs. *)

type primitive_address =
  | Prim_loaded of dll_address
  | Prim_exists

let find_primitive_for_execution prim_name =
  let rec find seen = function
    [] ->
      None
  | (_, dll) as curr :: rem ->
      let addr = dll_sym dll prim_name in
      if addr == Obj.magic () then find (curr :: seen) rem else begin
        if seen <> [] then dlls_opened_for_execution :=
          curr :: List.rev_append seen rem;
        Some (Prim_loaded addr)
      end
  in
  find [] !dlls_opened_for_execution

(* If linking in core (dynlink or toplevel), synchronize the VM
   table of primitive with the linker's table of primitive
   by storing the given primitive function at the given position
   in the VM table of primitives.  *)

let synchronize_primitive num symb =
  let actual_num = add_primitive symb in
  assert (actual_num = num)

(* Copied from config.generated.ml.in *)
let standard_library_default = {@QS@|@ocaml_libdir@|@QS@}

(* Copied from utils/config.common.ml.in *)
let standard_library =
  try
    Sys.getenv "OCAMLLIB"
  with Not_found ->
  try
    Sys.getenv "CAMLLIB"
  with Not_found ->
    standard_library_default

(* Read the [ld.conf] file and return the corresponding list of directories *)

let ld_conf_contents () =
  let path = ref [] in
  begin try
    let ic = open_in (Filename.concat standard_library "ld.conf") in
    begin try
      while true do
        path := input_line ic :: !path
      done
    with End_of_file -> ()
    end;
    close_in ic
  with Sys_error _ -> ()
  end;
  List.rev !path

let path_separator =
  match Sys.os_type with
  | "Win32" -> ';'
  | _ -> ':'

let split_path_contents ?(sep = path_separator) = function
  | "" -> []
  | s -> String.split_on_char sep s

(* Split the CAML_LD_LIBRARY_PATH environment variable and return
   the corresponding list of directories.  *)
let ld_library_path_contents () =
  match Sys.getenv "CAML_LD_LIBRARY_PATH" with
  | exception Not_found ->
      []
  | s ->
      split_path_contents s

let split_dll_path path =
  split_path_contents ~sep:'\000' path

(* Initialization for linking in core (dynlink or toplevel) *)

let init_toplevel dllpath =
  search_path :=
    ld_library_path_contents() @
    split_dll_path dllpath @
    ld_conf_contents();
  dlls_opened_for_execution :=
    List.map (fun dll -> "", dll)
      (Array.to_list (get_current_dlls()));
