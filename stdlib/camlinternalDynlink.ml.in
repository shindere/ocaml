(* @configure_input@ *)
#3 "camlinternalDynlink.ml.in"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*                   Sebastien Hinderer, Tarides, Paris                   *)
(*                                                                        *)
(*   Copyright 2022 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

[@@@ocaml.warning "-40"]

module LongString = struct
  type t = bytes array

  let create str_size =
    let tbl_size = str_size / Sys.max_string_length + 1 in
    let tbl = Array.make tbl_size Bytes.empty in
    for i = 0 to tbl_size - 2 do
      tbl.(i) <- Bytes.create Sys.max_string_length;
    done;
    tbl.(tbl_size - 1) <- Bytes.create (str_size mod Sys.max_string_length);
    tbl

  let length tbl =
    let tbl_size = Array.length tbl in
    Sys.max_string_length * (tbl_size - 1) + Bytes.length tbl.(tbl_size - 1)

  let get tbl ind =
    Bytes.get tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)

  let set tbl ind c =
    Bytes.set tbl.(ind / Sys.max_string_length) (ind mod Sys.max_string_length)
              c
  let blit src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      set dst (dstoff + i) (get src (srcoff + i))
    done

  let blit_string src srcoff dst dstoff len =
    for i = 0 to len - 1 do
      set dst (dstoff + i) (String.get src (srcoff + i))
    done

  let output oc tbl pos len =
    for i = pos to pos + len - 1 do
      output_char oc (get tbl i)
    done

  let input_bytes_into tbl ic len =
    let count = ref len in
    Array.iter (fun str ->
      let chunk = Int.min !count (Bytes.length str) in
      really_input ic str 0 chunk;
      count := !count - chunk) tbl

  let input_bytes ic len =
    let tbl = create len in
    input_bytes_into tbl ic len;
    tbl
end

let load_compunit_code ic code_size =
  let opRETURN = 40 in (* keep in sync with bytecomp/opcodes.ml *)
  let terminator = "\000\000\000\001\000\000\000" in
  let size = code_size + 8 in
  let code = LongString.create size in
  LongString.input_bytes_into code ic code_size;
  LongString.set code code_size (Char.chr opRETURN);
  LongString.blit_string terminator 0 code (code_size + 1) 7;
  code

(* Length of magic numbers, keep in sync with utils/misc.ml *)
let magic_length = 12

let cmo_magic_number = {@QS@|@CMO_MAGIC_NUMBER@|@QS@}
and cma_magic_number = {@QS@|@CMA_MAGIC_NUMBER@|@QS@}
and cmxs_magic_number = {@QS@|@CMXS_MAGIC_NUMBER@|@QS@}
and exec_magic_number = {@QS@|@EXEC_MAGIC_NUMBER@|@QS@}

(* The CMO format, keep in sync with file_formats/cmo_format.mli *)

type modname = string
type crcs = (modname * Digest.t option) list

(* Relocation information *)

type reloc_info =
    Reloc_literal of Obj.t                  (* structured constant *)
  | Reloc_getpredef of string               (* reference to a predef *)
  | Reloc_getglobal of string               (* reference to a global *)
  | Reloc_setglobal of string               (* definition of a global *)
  | Reloc_primitive of string               (* C primitive number *)

(* Descriptor for compilation units *)

type compilation_unit =
  { cu_name: modname;                   (* Name of compilation unit *)
    mutable cu_pos: int;                (* Absolute position in file *)
    cu_codesize: int;                   (* Size of code block *)
    cu_reloc: (reloc_info * int) list;  (* Relocation information *)
    cu_imports: crcs;                   (* Names and CRC of intfs imported *)
    cu_required_globals: string list;   (* Compilation units whose
                                           initialization side effects
                                           must occur before this one. *)
    cu_primitives: string list;         (* Primitives declared inside *)
    mutable cu_force_link: bool;        (* Must be linked even if unref'ed *)
    mutable cu_debug: int;              (* Position of debugging info, or 0 *)
    cu_debugsize: int }                 (* Length of debugging info *)

(* Format of a .cmo file:
     magic number (Config.cmo_magic_number)
     absolute offset of compilation unit descriptor
     block of relocatable bytecode
     debugging information if any
     compilation unit descriptor *)

(* Descriptor for libraries *)

type library =
  { lib_units: compilation_unit list;   (* List of compilation units *)
    lib_custom: bool;                   (* Requires custom mode linking? *)
    (* In the following fields the lists are reversed with respect to
       how they end up being used on the command line. *)
    lib_ccobjs: string list;            (* C object files needed for -custom *)
    lib_ccopts: string list;            (* Extra opts to C compiler *)
    lib_dllibs: string list }           (* DLLs needed *)

(* Format of a .cma file:
     magic number (Config.cma_magic_number)
     absolute offset of library descriptor
     object code for first library member
     ...
     object code for last library member
     library descriptor *)

(* The CMXS format, keep in sync with file_formats/cmxs_format.mli *)

(* Each .cmxs dynamically-loaded plugin contains a symbol
   "caml_plugin_header" containing the following info
   (as an externed record) *)

type dynunit = {
  dynu_name: modname;
  dynu_crc: Digest.t;
  dynu_imports_cmi: crcs;
  dynu_imports_cmx: crcs;
  dynu_defines: string list;
}

type dynheader = {
  dynu_magic: string;
  dynu_units: dynunit list;
}

exception Fatal_error

let fatal_errorf fmt =
  Format.kfprintf
    (fun _ -> raise Fatal_error)
    Format.err_formatter
    ("@?>> Fatal error: " ^^ fmt ^^ "@.")

let fatal_error msg = fatal_errorf "%s" msg

let ext_dll = "." ^ {@QS@|@SO@|@QS@}

(* Extract the name of a DLL from its external name (xxx.so or -lxxx) *)

let extract_dll_name file =
  if Filename.check_suffix file ext_dll then
    Filename.chop_suffix file ext_dll
  else if String.length file >= 2 && String.sub file 0 2 = "-l" then
    "dll" ^ String.sub file 2 (String.length file - 2)
  else
    file (* will cause error later *)

(* Handling of dynamically-linked libraries *)

type dll_handle
type dll_address

external dll_open: string -> dll_handle = "caml_dynlink_open_lib"
external dll_close: dll_handle -> unit = "caml_dynlink_close_lib"
external dll_sym: dll_handle -> string -> dll_address
                = "caml_dynlink_lookup_symbol"
         (* returned dll_address may be Val_unit *)

external add_primitive: dll_address -> int = "caml_dynlink_add_primitive"
external get_current_dlls: unit -> dll_handle array
                                           = "caml_dynlink_get_current_libs"

(* Current search path for DLLs *)
let search_path = ref ([] : string list)

(* DLLs currently opened for execution *)
let dlls_opened_for_execution = ref ([] : (string * dll_handle) list)

(* Add the given directories to the search path for DLLs. *)
let add_path dirs =
  search_path := dirs @ !search_path

(* Use the given directories as the search path for DLLs. *)
let set_path dirs =
  search_path := dirs

let remove_path dirs =
  search_path := List.filter (fun d -> not (List.mem d dirs)) !search_path

(* Copied from utils/misc.ml *)
let find_in_path path name =
  if not (Filename.is_implicit name) then
    if Sys.file_exists name then name else raise Not_found
  else begin
    let rec try_dir = function
      [] -> raise Not_found
    | dir::rem ->
        let fullname = Filename.concat dir name in
        if Sys.file_exists fullname then fullname else try_dir rem
    in try_dir path
  end

let fullname_of_name name =
  let name = name ^ ext_dll in
  try
    let fullname = find_in_path !search_path name in
    if Filename.is_implicit fullname then
      Filename.concat Filename.current_dir_name fullname
    else fullname
  with Not_found -> name

let open_dll_for_execution name =
  let fullname = fullname_of_name name in
  match List.assoc_opt fullname !dlls_opened_for_execution with
  | Some _ -> () (* DLL has already been opened *)
  | None ->
      begin match dll_open fullname with
      | dll ->
          dlls_opened_for_execution :=
            (fullname, dll) :: !dlls_opened_for_execution
      | exception Failure msg ->
          failwith (fullname ^ ": " ^ msg)
      end

(* Close all DLLs *)

let close_all_dlls () =
  List.iter (fun (_, dll) -> dll_close dll) !dlls_opened_for_execution;
  dlls_opened_for_execution := []

(* Find a primitive in the currently opened DLLs. *)

type primitive_address =
  | Prim_loaded of dll_address
  | Prim_exists

let find_primitive_for_execution prim_name =
  let rec find seen = function
    [] ->
      None
  | (_, dll) as curr :: rem ->
      let addr = dll_sym dll prim_name in
      if addr == Obj.magic () then find (curr :: seen) rem else begin
        if seen <> [] then dlls_opened_for_execution :=
          curr :: List.rev_append seen rem;
        Some (Prim_loaded addr)
      end
  in
  find [] !dlls_opened_for_execution

(* If linking in core (dynlink or toplevel), synchronize the VM
   table of primitive with the linker's table of primitive
   by storing the given primitive function at the given position
   in the VM table of primitives.  *)

let synchronize_primitive num symb =
  let actual_num = add_primitive symb in
  assert (actual_num = num)

(* Copied from config.generated.ml.in *)
let standard_library_default = {@QS@|@ocaml_libdir@|@QS@}

(* Copied from utils/config.common.ml.in *)
let standard_library =
  try
    Sys.getenv "OCAMLLIB"
  with Not_found ->
  try
    Sys.getenv "CAMLLIB"
  with Not_found ->
    standard_library_default

(* Read the [ld.conf] file and return the corresponding list of directories *)

let ld_conf_contents () =
  let path = ref [] in
  begin try
    let ic = open_in (Filename.concat standard_library "ld.conf") in
    begin try
      while true do
        path := input_line ic :: !path
      done
    with End_of_file -> ()
    end;
    close_in ic
  with Sys_error _ -> ()
  end;
  List.rev !path

let path_separator =
  match Sys.os_type with
  | "Win32" -> ';'
  | _ -> ':'

let split_path_contents ?(sep = path_separator) = function
  | "" -> []
  | s -> String.split_on_char sep s

(* Split the CAML_LD_LIBRARY_PATH environment variable and return
   the corresponding list of directories.  *)
let ld_library_path_contents () =
  match Sys.getenv "CAML_LD_LIBRARY_PATH" with
  | exception Not_found ->
      []
  | s ->
      split_path_contents s

let split_dll_path path =
  split_path_contents ~sep:'\000' path

(* Initialization for linking in core (dynlink or toplevel) *)

let init_toplevel dllpath =
  search_path :=
    ld_library_path_contents() @
    split_dll_path dllpath @
    ld_conf_contents();
  dlls_opened_for_execution :=
    List.map (fun dll -> "", dll)
      (Array.to_list (get_current_dlls()));

(* The following declarations were in bytecomp/meta.ml *)

external global_data : unit -> Obj.t array = "caml_get_global_data"
external realloc_global_data : int -> unit = "caml_realloc_global"
type closure = unit -> Obj.t
type bytecode
external reify_bytecode :
  bytes array -> 'a -> string option ->
    bytecode * closure
                           = "caml_reify_bytecode"
external release_bytecode : bytecode -> unit
                                 = "caml_static_release_bytecode"
external invoke_traced_function : Obj.raw_data -> Obj.t -> Obj.t -> Obj.t
                                = "caml_invoke_traced_function"
external get_section_table : unit -> (string * Obj.t) list
                           = "caml_get_section_table"
module MiniBytesections = struct
  (* This code is copied from bytecomp/bytesections.ml  and adapted *)
  (* We use a different module name to make sure all the references
     get updated *)
  exception Bad_magic_number (* Possibly add a string argument? *)

  let section_table = ref ([] : (string * int) list)

  let read_toc ic =
    let pos_trailer = in_channel_length ic - 16 in
    seek_in ic pos_trailer;
    let num_sections = input_binary_int ic in
    let header =
      really_input_string ic (String.length exec_magic_number)
    in
    if header <> exec_magic_number then raise Bad_magic_number;
    seek_in ic (pos_trailer - 8 * num_sections);
    section_table := [];
    for _i = 1 to num_sections do
      let name = really_input_string ic 4 in
      let len = input_binary_int ic in
      section_table := (name, len) :: !section_table
    done

  let seek_section ic name =
    let rec seek_sec curr_ofs = function
      [] -> raise Not_found
    | (n, len) :: rem ->
        if n = name
        then begin seek_in ic (curr_ofs - len); len end
        else seek_sec (curr_ofs - len) rem in
    seek_sec (in_channel_length ic - 16 - 8 * List.length !section_table)
             !section_table

  let read_section_string ic name =
    really_input_string ic (seek_section ic name)

  let read_section_struct ic name =
    ignore (seek_section ic name);
    input_value ic
end

module MiniSymtable = struct
  type error =
      Undefined_global of string
    | Unavailable_primitive of string
    | Wrong_vm of string
    | Uninitialized_global of string

  exception Error of error

  module StringMap = Map.Make(String)

  module Num_tbl (M : Map.S) = struct
    type t = {
      cnt: int; (* The next number *)
      tbl: int M.t ; (* The table of already numbered objects *)
    }

    let empty = { cnt = 0; tbl = M.empty }

    let find nt key =
      M.find key nt.tbl

    let enter nt key =
      let n = !nt.cnt in
      nt := { cnt = n + 1; tbl = M.add key n !nt.tbl };
      n

    let incr nt =
      let n = !nt.cnt in
      nt := { cnt = n + 1; tbl = !nt.tbl };
      n

  end
  module GlobalMap = Num_tbl(StringMap)

  module PrimMap = Num_tbl(StringMap)

  type global_map = GlobalMap.t

  let empty_global_map = GlobalMap.empty

  let global_table = ref GlobalMap.empty
  and literal_table = ref([] : (int * Obj.t) list)

  let c_prim_table = ref PrimMap.empty

  let set_prim_table name =
    ignore(PrimMap.enter c_prim_table name)

  let host = {@QS@|@host@|@QS@}
  let target = {@QS@|@target@|@QS@}

  let of_prim find_primitive name =
    try
      PrimMap.find !c_prim_table name
    with Not_found ->
      if (* !Clflags.custom_runtime || *) host <> target
         (* || !Clflags.no_check_prims *)
      then
        PrimMap.enter c_prim_table name
      else begin
        match find_primitive name with
        | None -> raise(Error(Unavailable_primitive name))
        | Some Prim_exists ->
            PrimMap.enter c_prim_table name
        | Some (Prim_loaded symb) ->
            let num = PrimMap.enter c_prim_table name in
            synchronize_primitive num symb;
            num
      end

  let required_globals patchlist =
    List.fold_left (fun accu rel ->
        match rel with
        | (Reloc_getglobal id, _pos) -> id :: accu
        | _ -> accu)
      []
      patchlist
  
  let defined_globals patchlist =
    List.fold_left (fun accu rel ->
        match rel with
        | (Reloc_setglobal id, _pos) -> id :: accu
        | _ -> accu)
      []
      patchlist

  let slot_for_getglobal id =
    try
      GlobalMap.find !global_table id
    with Not_found ->
      raise(Error(Undefined_global id))

  let slot_for_setglobal id =
    GlobalMap.enter global_table id

  let slot_for_literal cst =
    let n = GlobalMap.incr global_table in
    literal_table := (n, cst) :: !literal_table;
    n

  type section_reader = {
    read_string: string -> string;
    read_struct: string -> Obj.t;
    close_reader: unit -> unit
  }

  let read_sections () =
    try
      let sections = get_section_table () in
      { read_string =
          (fun name -> (Obj.magic(List.assoc name sections) : string));
        read_struct =
          (fun name -> List.assoc name sections);
        close_reader =
          (fun () -> ()) }
    with Not_found ->
      let ic = open_in_bin Sys.executable_name in
      MiniBytesections.read_toc ic;
      { read_string = MiniBytesections.read_section_string ic;
        read_struct = MiniBytesections.read_section_struct ic;
        close_reader = fun () -> close_in ic }

  let init_toplevel () =
    try
      let sect = read_sections () in
      (* Locations of globals *)
      global_table := (Obj.magic (sect.read_struct "SYMB") : GlobalMap.t);
      (* Primitives *)
      let prims = sect.read_string "PRIM" in
      c_prim_table := PrimMap.empty;
      let pos = ref 0 in
      while !pos < String.length prims do
        let i = String.index_from prims !pos '\000' in
        set_prim_table (String.sub prims !pos (i - !pos));
        pos := i + 1
      done;
      (* DLL initialization *)
      let dllpath = try sect.read_string "DLPT" with Not_found -> "" in
      init_toplevel dllpath;
      (* Recover CRC infos for interfaces *)
      let crcintfs =
        try
          (Obj.magic (sect.read_struct "CRCS") : (string * Digest.t option) list)
        with Not_found -> [] in
      (* Done *)
      sect.close_reader();
      crcintfs
    with MiniBytesections.Bad_magic_number
    | Not_found | Failure _ ->
      fatal_error "Toplevel bytecode executable is corrupted"

  let current_state () = !global_table

  let is_defined_in_global_map (gmap : global_map) id =
    StringMap.mem id gmap.tbl

  let patch_int buff pos n =
    LongString.set buff pos (Char.unsafe_chr n);
    LongString.set buff (pos + 1) (Char.unsafe_chr (n asr 8));
    LongString.set buff (pos + 2) (Char.unsafe_chr (n asr 16));
    LongString.set buff (pos + 3) (Char.unsafe_chr (n asr 24))

  let patch_object find_primitive buff patchlist =
    List.iter
      (function
          (Reloc_literal sc, pos) ->
            patch_int buff pos (slot_for_literal sc)
        | (Reloc_getglobal id, pos) | (Reloc_getpredef id, pos) ->
            patch_int buff pos (slot_for_getglobal id)
        | (Reloc_setglobal id, pos) ->
            patch_int buff pos (slot_for_setglobal id)
        | (Reloc_primitive name, pos) ->
            patch_int buff pos (of_prim find_primitive name))
      patchlist

  let get_global_value id = (global_data()).(slot_for_getglobal id)

  let check_global_initialized patchlist =
    (* First determine the globals we will define *)
    let defined_globals = defined_globals patchlist in
    (* Then check that all referenced, not defined globals have a value *)
    let check_reference = function
        (Reloc_getglobal id, _pos) ->
          if not (List.mem id defined_globals)
          && Obj.is_int (get_global_value id)
          then raise (Error(Uninitialized_global id))
      | _ -> () in
    List.iter check_reference patchlist

  let update_global_table () =
    let ng = !global_table.cnt in
    let glob = global_data() in
    if ng > Array.length(glob) then 
      realloc_global_data ng;
    let glob = global_data() in
    List.iter
      (fun (slot, cst) -> glob.(slot) <- cst)
      !literal_table;
    literal_table := []

  let hide_additions (st : global_map) =
    if st.cnt > !global_table.cnt then
      fatal_error "Symtable.hide_additions";
    global_table :=
      {GlobalMap.
        cnt = !global_table.cnt;
        tbl = st.tbl }
end
